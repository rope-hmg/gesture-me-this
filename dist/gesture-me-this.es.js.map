{"version":3,"file":"gesture-me-this.es.js","sources":["../src/vector.ts","../src/metrics.ts","../src/finger.ts","../src/controller.ts","../src/gestures/pinch.ts"],"sourcesContent":["export class Vector {\n  constructor(\n    public x: number,\n    public y: number,\n  ) {}\n\n  add(rhs: ReadonlyVector, out = new Vector(0, 0)): Vector {\n    out.x = this.x + rhs.x;\n    out.y = this.y + rhs.y;\n\n    return out;\n  }\n\n  add_assign(rhs: ReadonlyVector): Vector {\n    return this.add(rhs, this);\n  }\n\n  sub(rhs: ReadonlyVector, out = new Vector(0, 0)): Vector {\n    out.x = this.x - rhs.x;\n    out.y = this.y - rhs.y;\n\n    return out;\n  }\n\n  sub_assign(rhs: ReadonlyVector): Vector {\n    return this.sub(rhs, this);\n  }\n\n  mul(rhs: number, out = new Vector(0, 0)): Vector {\n    out.x = this.x * rhs;\n    out.y = this.y * rhs;\n\n    return out;\n  }\n\n  mul_assign(rhs: number): Vector {\n    return this.mul(rhs, this);\n  }\n\n  div(rhs: number, out = new Vector(0, 0)): Vector {\n    return this.mul(1 / rhs, out);\n  }\n\n  div_assign(rhs: number): Vector {\n    return this.mul_assign(1 / rhs);\n  }\n\n  neg(out = new Vector(0, 0)): Vector {\n    return this.mul(-1, out);\n  }\n\n  neg_assign(): Vector {\n    return this.mul_assign(-1);\n  }\n\n  dot(rhs: ReadonlyVector): number {\n    return this.x * rhs.x + this.y * rhs.y;\n  }\n\n  cross(rhs: ReadonlyVector): number {\n    return this.x * rhs.y - this.y * rhs.x;\n  }\n\n  length_sq(): number {\n    return this.dot(this);\n  }\n\n  length(): number {\n    return Math.sqrt(this.length_sq());\n  }\n\n  normalise(out = new Vector(0, 0)): Vector {\n    return this.mul(1 / this.length(), out);\n  }\n\n  normalise_assign(): Vector {\n    return this.mul_assign(1 / this.length());\n  }\n\n  copy_from(rhs: ReadonlyVector): Vector {\n    this.x = rhs.x;\n    this.y = rhs.y;\n\n    return this;\n  }\n\n  set(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nexport interface ReadonlyVector {\n  readonly x: number;\n  readonly y: number;\n\n  add(rhs: ReadonlyVector, out?: Vector): Vector;\n  sub(rhs: ReadonlyVector, out?: Vector): Vector;\n  mul(rhs: number, out?: Vector): Vector;\n  div(rhs: number, out?: Vector): Vector;\n  dot(rhs: ReadonlyVector): number;\n  cross(rhs: ReadonlyVector): number;\n  length_sq(): number;\n  length(): number;\n  normalise(out?: Vector): Vector;\n}\n\nexport type ReadonlyPoint = ReadonlyVector;\n","import { Vector, ReadonlyPoint } from \"./vector\";\nimport { Finger, ReadonlyFinger } from \"./finger\";\n\nexport class Metrics {\n  finger_count = 0;\n  fingers = new Map<number, Finger>();\n  centroid = new Vector(0, 0);\n\n  // average_finger_direction(): Vector {\n  //   const average_direction = new Vector(0, 0);\n\n  //   if (this.finger_count > 1) {\n  //     for (const finger of this.fingers.values()) {\n  //       average_direction.add_assign(finger.position_delta);\n  //     }\n\n  //     average_direction.div_assign(this.finger_count);\n  //   }\n\n  //   return average_direction;\n  // }\n}\n\nexport interface ReadonlyMetrics {\n  /** The number of fingers currently touching the screen */\n  readonly finger_count: number;\n\n  /** The finger data */\n  readonly fingers: ReadonlyMap<number, ReadonlyFinger>;\n\n  /** The average position of the fingers */\n  readonly centroid: ReadonlyPoint;\n\n  // average_finger_direction(): Vector;\n}\n","import { Vector, ReadonlyVector, ReadonlyPoint } from \"./vector\";\n\n/** Represents an  */\nexport class Finger {\n  position: Vector;\n  position_delta = new Vector(0, 0);\n  centroid_direction = new Vector(0, 0);\n\n  constructor(x: number, y: number) {\n    this.position = new Vector(x, y);\n  }\n\n  is_moving_toward_centroid(): boolean {\n    // We determine the direction of movement by taking the dot product of the centroid_direction\n    // and the position_delta. If the result is negative then the finger is moving away from the centroid.\n    //\n    // The position_delta moved us from the previous position to the current position.\n    // The centroid_direction is the vector from the finger's position to the centroid.\n    return this.position_delta.dot(this.centroid_direction) > 0;\n  }\n\n  /** Returns the angle around `point` that the finger moved in radians  */\n  angle_delta_around_point(point: Vector): number {\n    const previous_position_normal = this.position\n      .sub(this.position_delta)\n      .sub_assign(point)\n      .normalise_assign();\n\n    const current_position_normal = this.position.sub(point).normalise_assign();\n\n    return Math.acos(previous_position_normal.dot(current_position_normal));\n  }\n}\n\nexport interface ReadonlyFinger {\n  /** The position of the finger */\n  position: ReadonlyPoint;\n  /** The vector that translated the previous position to the current one  */\n  position_delta: ReadonlyVector;\n  /** The direction of the gesture's centoid from the finger's position */\n  centroid_direction: ReadonlyVector;\n\n  is_moving_toward_centroid(): boolean;\n  angle_delta_around_point(point: Vector): number;\n}\n","import { Metrics, ReadonlyMetrics } from \"./metrics\";\nimport { Finger } from \"./finger\";\n\nexport enum EventType {\n  OnStart,\n  OnMove,\n  OnEnd,\n  OnCancel,\n}\n\nexport type TouchHandler = (\n  metrics: ReadonlyMetrics,\n  event: TouchEvent,\n) => void;\n\ntype InternalTouchEventHandler = (event: TouchEvent) => void;\n\nexport class GestureController {\n  private metrics = new Metrics();\n\n  private on_start: InternalTouchEventHandler;\n  private on_move: InternalTouchEventHandler;\n  private on_end: InternalTouchEventHandler;\n  private on_cancel: InternalTouchEventHandler;\n\n  private constructor(\n    private element: HTMLElement,\n    private listeners: Map<EventType, TouchHandler[]>,\n  ) {\n    const on_start: InternalTouchEventHandler = (event) => {\n      event.preventDefault();\n      this.initialise_touches(event.changedTouches);\n      this.run_user_handlers(event, EventType.OnStart);\n    };\n\n    const on_move: InternalTouchEventHandler = (event) => {\n      event.preventDefault();\n      this.update_touches(event.changedTouches);\n      this.run_user_handlers(event, EventType.OnMove);\n    };\n\n    const on_end: InternalTouchEventHandler = (event) => {\n      event.preventDefault();\n      this.remove_touches(event.changedTouches);\n      this.run_user_handlers(event, EventType.OnEnd);\n    };\n\n    const on_cancel: InternalTouchEventHandler = (event) => {\n      event.preventDefault();\n      this.remove_all_touches();\n      this.run_user_handlers(event, EventType.OnCancel);\n    };\n\n    element.addEventListener(\"touchstart\", on_start);\n    element.addEventListener(\"touchmove\", on_move);\n    element.addEventListener(\"touchend\", on_end);\n    element.addEventListener(\"touchcancel\", on_cancel);\n\n    this.on_start = on_start;\n    this.on_move = on_move;\n    this.on_end = on_end;\n    this.on_cancel = on_cancel;\n  }\n\n  /** Removes the touch event listeners from the element */\n  disableGestures(): void {\n    this.element.removeEventListener(\"touchstart\", this.on_start);\n    this.element.removeEventListener(\"touchmove\", this.on_move);\n    this.element.removeEventListener(\"touchmove\", this.on_end);\n    this.element.removeEventListener(\"touchmove\", this.on_cancel);\n  }\n\n  private run_user_handlers(event: TouchEvent, type: EventType): void {\n    const handlers = this.listeners.get(type);\n\n    if (handlers) {\n      for (const handler of handlers) {\n        handler(this.metrics, event);\n      }\n    }\n  }\n\n  private initialise_touches(touches: TouchList): void {\n    this.metrics.finger_count += touches.length;\n\n    for (const touch of touches) {\n      const finger = new Finger(touch.clientX, touch.clientY);\n      this.metrics.fingers.set(touch.identifier, finger);\n    }\n\n    this.calculate_centroid();\n  }\n\n  private update_touches(touches: TouchList): void {\n    for (const touch of touches) {\n      const finger = this.metrics.fingers.get(touch.identifier);\n\n      if (finger) {\n        finger.position_delta.set(\n          touch.clientX - finger.position.x,\n          touch.clientY - finger.position.y,\n        );\n\n        finger.position.set(touch.clientX, touch.clientY);\n      }\n    }\n\n    this.calculate_centroid();\n  }\n\n  private remove_touches(touches: TouchList): void {\n    this.metrics.finger_count -= touches.length;\n\n    for (const touch of touches) {\n      this.metrics.fingers.delete(touch.identifier);\n    }\n\n    this.calculate_centroid();\n  }\n\n  private remove_all_touches(): void {\n    this.metrics.finger_count = 0;\n    this.metrics.fingers.clear();\n    this.metrics.centroid.set(0, 0);\n  }\n\n  private calculate_centroid(): void {\n    const { finger_count, fingers, centroid } = this.metrics;\n\n    centroid.set(0, 0);\n\n    for (const finger of fingers.values()) {\n      centroid.add_assign(finger.position);\n    }\n\n    if (finger_count > 1) {\n      centroid.div_assign(finger_count);\n    }\n\n    for (const finger of fingers.values()) {\n      centroid.sub(finger.position, finger.centroid_direction);\n    }\n  }\n}\n","import { GestureRecogniser, RecognitionOptions } from \".\";\nimport { Finger } from \"../finger\";\n\nexport enum PinchDirection {\n  Inward,\n  Outward,\n}\n\nexport type PinchMetrics = {\n  /**\n   * The strength of the pinch. The value indicates the average travel distance of all the fingers.\n   */\n  strength: number;\n\n  /**\n   * The direction of the pinch.\n   * - `PinchDirection.Inward` if the fingers are moving towards each other.\n   * - `PinchDirection.Outward` if the fingers are moving away from each other.\n   */\n  direction: PinchDirection;\n};\n\nconst DEFAULT_PINCH_ZOOM_OPTIONS: RecognitionOptions = {\n  sensitivity: 0.5,\n};\n\n/**\n * Recognises a pinchZoom gesture.\n * @param metrics The metrics to recognise the gesture from.\n * @param options The options to use when recognising the gesture.\n * @param options.exactFingerCount The number of fingers required to recognise the gesture. If left undefined, the gesture recogniser is required to recognise any count that is valid for it. Defaults to `0.5`.\n * @param options.sensitivity The sensitivity of the gesture recogniser. The provided values should be normalised in the range [0, 1].\n * @returns A `RecognitionResult<PinchMetrics>` indicating whether the gesture was recognised or not.\n * @see PinchMetrics\n */\nexport const pinch_zoom: GestureRecogniser<PinchMetrics> = (\n  metrics,\n  options,\n) => {\n  const { exact_finger_count, sensitivity = 0.5 } =\n    options ?? DEFAULT_PINCH_ZOOM_OPTIONS;\n\n  const matches_finger_count =\n    (Boolean(exact_finger_count) &&\n      metrics.finger_count === exact_finger_count) ||\n    (!exact_finger_count && metrics.finger_count > 1);\n\n  let pinch_metrics: PinchMetrics | undefined;\n\n  if (matches_finger_count) {\n    const fingers = metrics.fingers.values();\n\n    let { value: finger, done } = fingers.next();\n    let moving_toward_centroid = finger.is_moving_toward_centroid();\n\n    let all_moving_in_same_direction = true;\n\n    while (!done && all_moving_in_same_direction) {\n      all_moving_in_same_direction =\n        moving_toward_centroid === finger.is_moving_toward_centroid();\n\n      ({ value: finger, done } = fingers.next());\n    }\n\n    if (all_moving_in_same_direction) {\n      const direction = moving_toward_centroid\n        ? PinchDirection.Inward\n        : PinchDirection.Outward;\n\n      // We determine the strength of the pinch by taking the average of the distances that each finger has moved.\n      let strength = 0;\n\n      for (const finger of metrics.fingers.values()) {\n        strength += finger.position_delta.length();\n      }\n\n      strength /= metrics.finger_count;\n      strength *= sensitivity;\n\n      pinch_metrics = { strength, direction };\n    }\n  }\n\n  return pinch_metrics\n    ? { is_recognised: true, metrics: pinch_metrics }\n    : { is_recognised: false };\n};\n"],"names":["Vector","x","y","rhs","out","Metrics","Finger","point","previous_position_normal","current_position_normal","EventType","EventType2","GestureController","element","listeners","on_start","event","on_move","on_end","on_cancel","type","handlers","handler","touches","touch","finger","finger_count","fingers","centroid","PinchDirection","PinchDirection2","DEFAULT_PINCH_ZOOM_OPTIONS","pinch_zoom","metrics","options","exact_finger_count","sensitivity","matches_finger_count","pinch_metrics","done","moving_toward_centroid","all_moving_in_same_direction","direction","strength"],"mappings":"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"}